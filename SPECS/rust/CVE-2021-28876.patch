From 8cf74cab4b83291f1b500d1763139be1de656d64 Mon Sep 17 00:00:00 2001
From: Thomas Crain <thcrain@microsoft.com>
Date: Mon, 19 Apr 2021 14:44:48 -0500
Subject: [PATCH] Rust CVES

CVE-2021-28876: https://github.com/rust-lang/rust/pull/81741
CVE-2021-28877: https://github.com/rust-lang/rust/pull/80670
CVE-2021-28878: https://github.com/rust-lang/rust/pull/82292
CVE-2021-28879: https://github.com/rust-lang/rust/pull/82289

---
 library/core/src/iter/adapters/zip.rs | 24 ++++++----
 library/core/tests/iter.rs            | 63 +++++++++++++++++++++++++++
 library/core/tests/lib.rs             |  1 +
 3 files changed, 80 insertions(+), 8 deletions(-)

diff --git a/library/core/src/iter/adapters/zip.rs b/library/core/src/iter/adapters/zip.rs
index 581ac6e0d82..2aac006ba8b 100644
--- a/library/core/src/iter/adapters/zip.rs
+++ b/library/core/src/iter/adapters/zip.rs
@@ -16,9 +16,10 @@ use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterat
 pub struct Zip<A, B> {
     a: A,
     b: B,
-    // index and len are only used by the specialized version of zip
+    // index, len and a_len are only used by the specialized version of zip
     index: usize,
     len: usize,
+    a_len: usize,
 }
 impl<A: Iterator, B: Iterator> Zip<A, B> {
     pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {
@@ -113,6 +114,7 @@ where
             b,
             index: 0, // unused
             len: 0,   // unused
+            a_len: 0, // unused
         }
     }
 
@@ -187,8 +189,9 @@ where
     B: TrustedRandomAccess + Iterator,
 {
     fn new(a: A, b: B) -> Self {
-        let len = cmp::min(a.size(), b.size());
-        Zip { a, b, index: 0, len }
+        let a_len = a.size();
+        let len = cmp::min(a_len, b.size());
+        Zip { a, b, index: 0, len, a_len }
     }
 
     #[inline]
@@ -196,17 +199,19 @@ where
         if self.index < self.len {
             let i = self.index;
             self.index += 1;
+            self.len += 1;
             // SAFETY: `i` is smaller than `self.len`, thus smaller than `self.a.len()` and `self.b.len()`
             unsafe {
                 Some((self.a.__iterator_get_unchecked(i), self.b.__iterator_get_unchecked(i)))
             }
-        } else if A::may_have_side_effect() && self.index < self.a.size() {
+        } else if A::may_have_side_effect() && self.index < self.a_len {
+            let i = self.index;
+            self.index += 1;
             // match the base implementation's potential side effects
-            // SAFETY: we just checked that `self.index` < `self.a.len()`
+            // SAFETY: we just checked that `i` < `self.a.len()`
             unsafe {
-                self.a.__iterator_get_unchecked(self.index);
+                self.a.__iterator_get_unchecked(i);
             }
-            self.index += 1;
             None
         } else {
             None
@@ -262,9 +267,10 @@ where
             if sz_a != sz_b {
                 let sz_a = self.a.size();
                 if a_side_effect && sz_a > self.len {
-                    for _ in 0..sz_a - cmp::max(self.len, self.index) {
+                    for _ in 0..sz_a - self.len {
                         self.a.next_back();
                     }
+                    self.a_len = self.len;
                 }
                 let sz_b = self.b.size();
                 if b_side_effect && sz_b > self.len {
@@ -276,6 +282,7 @@ where
         }
         if self.index < self.len {
             self.len -= 1;
+            self.a_len -= 1;
             let i = self.len;
             // SAFETY: `i` is smaller than the previous value of `self.len`,
             // which is also smaller than or equal to `self.a.len()` and `self.b.len()`
@@ -289,6 +296,7 @@ where
 
     #[inline]
     unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {
+        let idx = self.index + idx;
         // SAFETY: the caller must uphold the contract for
         // `Iterator::get_unchecked`.
         unsafe { (self.a.__iterator_get_unchecked(idx), self.b.__iterator_get_unchecked(idx)) }
diff --git a/library/core/tests/iter.rs b/library/core/tests/iter.rs
index 00e3972c42f..088ea4ebc41 100644
--- a/library/core/tests/iter.rs
+++ b/library/core/tests/iter.rs
@@ -401,6 +401,26 @@ fn test_zip_nth_back_side_effects_exhausted() {
     assert_eq!(b, vec![200, 300, 400]);
 }
 
+#[test]
+fn test_zip_trusted_random_access_composition() {
+    let a = [0, 1, 2, 3, 4];
+    let b = a;
+    let c = a;
+
+    let a = a.iter().copied();
+    let b = b.iter().copied();
+    let mut c = c.iter().copied();
+    c.next();
+
+    let mut z1 = a.zip(b);
+    assert_eq!(z1.next().unwrap(), (0, 0));
+
+    let mut z2 = z1.zip(c);
+    fn assert_trusted_random_access<T: TrustedRandomAccess>(_a: &T) {}
+    assert_trusted_random_access(&z2);
+    assert_eq!(z2.next().unwrap(), ((1, 1), 1));
+}
+
 #[test]
 fn test_iterator_step_by() {
     // Identity
@@ -1882,6 +1902,49 @@ fn test_double_ended_zip() {
     assert_eq!(it.next(), None);
 }
 
+#[test]
+fn test_issue_82282() {
+    fn overflowed_zip(arr: &[i32]) -> impl Iterator<Item = (i32, &())> {
+        static UNIT_EMPTY_ARR: [(); 0] = [];
+
+        let mapped = arr.into_iter().map(|i| *i);
+        let mut zipped = mapped.zip(UNIT_EMPTY_ARR.iter());
+        zipped.next();
+        zipped
+    }
+
+    let arr = [1, 2, 3];
+    let zip = overflowed_zip(&arr).zip(overflowed_zip(&arr));
+
+    assert_eq!(zip.size_hint(), (0, Some(0)));
+    for _ in zip {
+        panic!();
+    }
+}
+
+#[test]
+fn test_issue_82291() {
+    use std::cell::Cell;
+
+    let mut v1 = [()];
+    let v2 = [()];
+
+    let called = Cell::new(0);
+
+    let mut zip = v1
+        .iter_mut()
+        .map(|r| {
+            called.set(called.get() + 1);
+            r
+        })
+        .zip(&v2);
+
+    zip.next_back();
+    assert_eq!(called.get(), 1);
+    zip.next();
+    assert_eq!(called.get(), 1);
+}
+
 #[test]
 fn test_double_ended_filter() {
     let xs = [1, 2, 3, 4, 5, 6];
diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs
index 81e621318e1..0afa6045e85 100644
--- a/library/core/tests/lib.rs
+++ b/library/core/tests/lib.rs
@@ -45,6 +45,7 @@
 #![feature(partition_point)]
 #![feature(once_cell)]
 #![feature(unsafe_block_in_unsafe_fn)]
+#![feature(trusted_random_access)]
 #![deny(unsafe_op_in_unsafe_fn)]
 
 extern crate test;
-- 
2.25.1
